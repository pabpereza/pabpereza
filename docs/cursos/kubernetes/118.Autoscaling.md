---
title: 'Autoscaling en Kubernetes - HPA, VPA y Cluster Autoscaler'
description: >-
  Domina el autoscaling en Kubernetes con HPA, VPA y Cluster Autoscaler. Aprende
  escalado horizontal y vertical automático para aplicaciones en producción.
keywords:
  - kubernetes autoscaling
  - HPA kubernetes
  - VPA kubernetes
  - cluster autoscaler
  - escalado automático
  - horizontal pod autoscaler
  - vertical pod autoscaler
sidebar_label: Autoscaling
tags:
  - kubernetes
  - autoscaling
  - HPA
  - VPA
  - escalado
image: 'https://pabpereza.dev/img/banner_kubernetes.png'
slug: autoscaling_en_kubernetes_hpa_vpa_y_cluster_autoscaler
---

# Autoscaling en Kubernetes

El autoescalado es una de las características más potentes de Kubernetes, permitiendo que tus aplicaciones se adapten dinámicamente a la carga de trabajo. En esta lección nos centraremos en el **Horizontal Pod Autoscaler (HPA)**.

---
* Lista de vídeos en Youtube: [Curso Kubernetes](https://www.youtube.com/playlist?list=PLQhxXeq1oc2k9MFcKxqXy5GV4yy7wqSma)

## Introducción

Imagina que tienes una tienda online. Durante la noche tienes pocos visitantes, pero en el Black Friday el tráfico se dispara. Si tienes una infraestructura estática, o pagas de más por recursos que no usas de noche, o tu sitio se cae en el pico de tráfico.

Aquí es donde entra el **Autoscaling**. Kubernetes puede aumentar o disminuir automáticamente el número de réplicas de tus Pods basándose en métricas como el uso de CPU o memoria.

## Conceptos Fundamentales

### ¿Qué es el HPA (Horizontal Pod Autoscaler)?

El HPA escala el número de Pods en un replication controller, deployment, replica set o stateful set basándose en la utilización de CPU observada (o, con soporte de métricas personalizadas, en otras métricas de la aplicación).

*   **Escalado Horizontal**: Añadir más Pods (máquinas/contenedores) al pool.
*   **Escalado Vertical**: Añadir más recursos (CPU/RAM) a los Pods existentes (esto lo hace el VPA, que veremos en otra lección).

### Requisitos Previos

Para que el HPA funcione, necesitas tener el **Metrics Server** instalado en tu clúster. Este componente se encarga de recolectar las métricas de uso de recursos de los contenedores.

Puedes verificar si está funcionando con:
```bash
kubectl top nodes
kubectl top pods
```

## Ejemplo Práctico: HPA con uso de CPU

Vamos a desplegar una aplicación sencilla y configuraremos un HPA para que escale cuando el uso de CPU supere el 50%.

### 1. Desplegar la aplicación

Usaremos una imagen de `php-apache` que tiene una página `index.php` que realiza cálculos intensivos para generar carga de CPU.

Crea un archivo `php-apache.yaml`:

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: php-apache
spec:
  selector:
    matchLabels:
      run: php-apache
  replicas: 1
  template:
    metadata:
      labels:
        run: php-apache
    spec:
      containers:
      - name: php-apache
        image: registry.k8s.io/hpa-example
        ports:
        - containerPort: 80
        resources:
          limits:
            cpu: 500m
          requests:
            cpu: 200m
---
apiVersion: v1
kind: Service
metadata:
  name: php-apache
  labels:
    run: php-apache
spec:
  ports:
  - port: 80
  selector:
    run: php-apache
```

Aplica el manifiesto:

```bash
kubectl apply -f php-apache.yaml
```

### 2. Crear el Horizontal Pod Autoscaler

Ahora vamos a crear el HPA. Queremos mantener el uso de CPU promedio de todos los Pods en un 50%. Definiremos un mínimo de 1 réplica y un máximo de 10.

Puedes hacerlo imperativamente:

```bash
kubectl autoscale deployment php-apache --cpu-percent=50 --min=1 --max=10
```

O declarativamente con un YAML (`hpa.yaml`):

```yaml
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: php-apache
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: php-apache
  minReplicas: 1
  maxReplicas: 10
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 50
```

Aplica el HPA:
```bash
kubectl apply -f hpa.yaml
```

Verifica el estado del HPA:
```bash
kubectl get hpa
```
*Deberías ver algo como `TARGETS: 0%/50%`.*

### 3. Generar Carga

Vamos a iniciar un contenedor diferente que actuará como generador de carga, enviando peticiones infinitas a nuestro servicio `php-apache`.

Abre una nueva terminal y ejecuta:

```bash
kubectl run -i --tty load-generator --rm --image=busybox --restart=Never -- /bin/sh -c "while sleep 0.01; do wget -q -O- http://php-apache; done"
```

### 4. Observar el Escalado

Vuelve a tu terminal original y observa cómo reacciona el HPA. Puedes usar el flag `-w` (watch) para ver los cambios en tiempo real.

```bash
kubectl get hpa -w
```

Después de unos minutos, verás que la carga de CPU aumenta (por ejemplo, a `250%`) y el número de réplicas (`REPLICAS`) empezará a subir para intentar bajar la carga media al 50%.

```text
NAME         REFERENCE               TARGETS    MINPODS   MAXPODS   REPLICAS   AGE
php-apache   Deployment/php-apache   250%/50%   1         10        1          1m
php-apache   Deployment/php-apache   250%/50%   1         10        4          2m
php-apache   Deployment/php-apache   250%/50%   1         10        5          3m
```

### 5. Detener la carga

Si detienes el generador de carga (Ctrl+C en la otra terminal), verás que después de un periodo de enfriamiento (cooldown, por defecto 5 minutos), el número de réplicas volverá a bajar a 1.

## Conclusiones

El HPA es esencial para mantener la disponibilidad y el rendimiento de tus aplicaciones en Kubernetes sin intervención manual, optimizando al mismo tiempo el uso de recursos y costes.

Recuerda:
1.  Necesitas **Metrics Server**.
2.  Debes definir **Requests y Limits** en tus Pods para que el HPA pueda calcular los porcentajes correctamente.

## Recursos Adicionales

*   [Documentación oficial de Kubernetes sobre HPA](https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/)
*   [Metrics Server en GitHub](https://github.com/kubernetes-sigs/metrics-server)

[Volver al índice](README.md#índice)
