---
title: Resource Quotas y Limit Ranges en Kubernetes - Gesti√≥n de Recursos
description: >-
  Aprende a gestionar recursos en Kubernetes con Resource Quotas y Limit Ranges.
  Controla CPU, memoria y almacenamiento en namespaces con ejemplos pr√°cticos.
keywords:
  - kubernetes resource quotas
  - limit ranges kubernetes
  - gesti√≥n recursos kubernetes
  - CPU memoria limits
  - namespace quotas
  - kubernetes resource management
sidebar_label: Rangos y Quotas
tags:
  - kubernetes
  - resources
  - quotas
  - limits
  - CKA
image: 'https://pabpereza.dev/img/banner_kubernetes.png'
slug: resource_quotas_y_limit_ranges_en_kubernetes_gestion_de_recursos
---

# Gesti√≥n Avanzada de Recursos: ResourceQuotas y LimitRanges

## Introducci√≥n: Gesti√≥n de Recursos en Entornos Multi-tenant

En un cluster de Kubernetes compartido (multi-tenant), la gesti√≥n eficiente de los recursos computacionales es cr√≠tica para garantizar la estabilidad y el rendimiento.

Por defecto, un Pod en Kubernetes no tiene l√≠mites de recursos definidos. Puede consumir toda la CPU y memoria disponible en el nodo si la aplicaci√≥n lo requiere. Esta falta de restricciones conlleva dos riesgos operativos principales:
1.  **El problema del "Vecino Ruidoso" (Noisy Neighbor):** Una aplicaci√≥n con un comportamiento an√≥malo o un bug puede acaparar los recursos del nodo, degradando el rendimiento de otras cargas de trabajo cr√≠ticas que comparten la misma infraestructura.
2.  **OOMKilled (Out Of Memory):** Si el consumo de memoria excede la capacidad f√≠sica del nodo, el kernel de Linux invocar√° al OOM Killer para terminar procesos y liberar memoria. Este mecanismo puede terminar pods cr√≠ticos de forma impredecible.

Dentro v√≠deo: https://youtu.be/C5Zg08HkG6o
[![Video Thumbnail](https://i.ytimg.com/vi/C5Zg08HkG6o/maxresdefault.jpg)](https://youtu.be/C5Zg08HkG6o)

Para mitigar estos riesgos y gobernar el consumo de recursos, Kubernetes proporciona dos primitivas esenciales: **ResourceQuotas** (L√≠mites agregados a nivel de Namespace) y **LimitRanges** (Restricciones a nivel de Pod/Contenedor).

```mermaid
graph TD
    subgraph Cluster ["‚òÅÔ∏è Cluster Kubernetes"]
        subgraph NS ["üè¢ Namespace (El Edificio)"]
            style NS fill:#1f2023,stroke:#3b82f6,stroke-width:2px
            
            RQ["üëÆ ResourceQuota (Presupuesto Total: 8GB)"]
            style RQ fill:#d97706,stroke:#fff,color:#fff
            
            LR["ü§ñ LimitRange (Reglas por Defecto: 128MB)"]
            style LR fill:#10b981,stroke:#fff,color:#fff
            
            subgraph Pods
                P1["üì¶ Pod A (Usa 2GB)"]
                P2["üì¶ Pod B (Usa 4GB)"]
                P3["üì¶ Pod C (Usa ???)"]
            end
            
            RQ -.->|Controla la Suma| Pods
            LR -.->|Inyecta valores| P3
        end
    end
```

## 1. ResourceQuotas: Restricciones Agregadas por Namespace

Una **ResourceQuota** es un objeto que impone restricciones sobre el consumo total de recursos agregados dentro de un Namespace. Su funci√≥n principal es limitar la cantidad total de recursos de c√≥mputo y almacenamiento que pueden ser consumidos por todos los objetos dentro de ese espacio de nombres.

### Capacidades de Control
*   **Recursos de C√≥mputo:** Suma total de CPU y Memoria (tanto `requests` como `limits`).
*   **Conteo de Objetos:** N√∫mero m√°ximo de recursos permitidos (Pods, Services, PVCs, ConfigMaps, etc.).
*   **Almacenamiento:** Cantidad total de almacenamiento solicitada a trav√©s de PVCs.

### Ejemplo de Configuraci√≥n

```yaml
apiVersion: v1
kind: ResourceQuota
metadata:
  name: quota-namespace-backend
  namespace: backend
spec:
  hard:
    # L√≠mite total de recursos garantizados (requests)
    requests.memory: 8Gi
    
    # L√≠mite total absoluto (limits)
    limits.memory: 16Gi
    
    # Restricci√≥n de cantidad de objetos para proteger el plano de control
    pods: "10"
    services: "5"
```

> **Nota T√©cnica:** Si la creaci√≥n de un nuevo Pod resulta en que el consumo total del Namespace exceda cualquiera de estos valores, el servidor de la API rechazar√° la solicitud con un c√≥digo de estado `403 Forbidden`.

## 2. LimitRanges: Restricciones a Nivel de Contenedor

Mientras que ResourceQuota gestiona el total, el **LimitRange** establece restricciones granulares a nivel de **Pod y Contenedor individual**. Permite definir pol√≠ticas de recursos m√≠nimos y m√°ximos, as√≠ como asignar valores por defecto.



### Funciones Cr√≠ticas
1.  **Validaci√≥n:** Asegura que ning√∫n contenedor solicite recursos por debajo de un m√≠nimo √∫til o por encima de un m√°ximo permitido.
2.  **Asignaci√≥n por Defecto:** Inyecta autom√°ticamente valores de `request` y `limit` a los contenedores que no los especifican expl√≠citamente. Esto es vital en Namespaces con ResourceQuotas activas, ya que la quota exige que todo Pod tenga recursos definidos.

### Ejemplo de Configuraci√≥n

```yaml
apiVersion: v1
kind: LimitRange
metadata:
  name: limites-contenedor-backend
  namespace: backend
spec:
  limits:
  - type: Container
    # 1. Valores por defecto (aplicados si el manifiesto del Pod no los incluye)
    defaultRequest:
      memory: 128Mi
    default: # Corresponde a 'defaultLimit'
      memory: 512Mi
      
    # 2. L√≠mites m√°ximos permitidos por contenedor individual
    max:
      memory: 1Gi
      
    # 3. L√≠mites m√≠nimos requeridos
    min:
      memory: 64Mi
```

## Tabla Comparativa: ResourceQuota vs LimitRange

| Caracter√≠stica | ResourceQuota | LimitRange |
| :--- | :--- | :--- |
| **Alcance** | Namespace completo (Suma agregada). | Pod/Contenedor individual. |
| **Objetivo Principal** | Control de costes, cuotas de equipo y capacidad. | Estandarizaci√≥n, QoS y prevenci√≥n de abusos puntuales. |
| **M√©trica Controlada** | Total de CPU/Memoria usada en el Namespace. | Min/Max CPU/Memoria por unidad de ejecuci√≥n. |
| **Comportamiento** | Rechaza la creaci√≥n si se excede el total. | Rechaza (si viola min/max) o Muta (inyecta defaults). |

## Caso Pr√°ctico: Interacci√≥n de Pol√≠ticas
```mermaid
sequenceDiagram
    participant User as üë§ Dev
    participant API as ‚öôÔ∏è K8s API
    participant LR as ü§ñ LimitRange
    participant RQ as üëÆ ResourceQuota
    participant NS as üè¢ Namespace

    Note over NS: Estado Actual:<br/>Usado 3.5 CPU / L√≠mite 4.0 CPU
    
    User->>API: üöÄ Desplegar Pod (Sin especificar recursos)
    
    rect rgb(30, 30, 40)
        Note right of API: Paso 1: Admisi√≥n
        API->>LR: ¬øTiene defaults?
        LR-->>API: S√≠, aplica Default: 1 CPU
        Note right of API: El Pod ahora pide 1 CPU
    end
    
    rect rgb(50, 20, 20)
        Note right of API: Paso 2: Validaci√≥n de Cuota
        API->>RQ: ¬øCabe 1 CPU m√°s?
        RQ->>NS: Check Suma: 3.5 + 1.0 = 4.5 CPU
        NS-->>RQ: ‚ùå Excede L√≠mite (Max 4.0)
        RQ-->>API: ‚õî DENEGADO
    end
    
    API-->>User: üí• Error 403: Forbidden (Exceeded Quota)
```

Analicemos el flujo de admisi√≥n cuando ambas pol√≠ticas est√°n activas en el namespace `backend`:
1.  **Estado Actual:** ResourceQuota permite 4 CPU totales (3.5 CPU ya en uso). Disponible: **0.5 CPU**.
2.  **Pol√≠tica:** LimitRange define un `defaultRequest` de **1 CPU**.

**Escenario:** Se intenta desplegar un Pod sin especificaci√≥n de recursos.

**Flujo de Ejecuci√≥n:**
1.  El Pod es recibido por el API Server.
2.  El **LimitRange** (Admission Controller) detecta la ausencia de especificaciones e inyecta el `defaultRequest: 1 CPU`.
3.  El Pod modificado pasa a validaci√≥n de **ResourceQuota**.
4.  La Quota calcula el nuevo total: `3.5 (existente) + 1 (nuevo) = 4.5 CPU`.
5.  Como 4.5 excede el l√≠mite de 4, la Quota **RECHAZA** la solicitud.

**Resultado:** El despliegue falla. Aunque el usuario no solicit√≥ recursos expl√≠citamente, la pol√≠tica de asignaci√≥n por defecto provoc√≥ una violaci√≥n de la cuota agregada.

---
* Lista de v√≠deos en Youtube: [Curso Kubernetes](https://www.youtube.com/playlist?list=PLQhxXeq1oc2k9MFcKxqXy5GV4yy7wqSma)

[Volver al √≠ndice](README.md#√≠ndice)
